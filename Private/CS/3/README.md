# 程序的机器级表示

计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上，以及利用网络通信。编译器基于编译语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。

GCC C语言编译器以汇编代码的形式产出输出，汇编代码是机器代码的文本显示，给出程序中的每一条指令。然后 GCC 调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

当我们使用高级语言编程的时候，机器屏蔽了程序的细节，即机器级的实现。能够阅读和理解汇编代码对于程序来说是一项很重要的技能，通过阅读这些汇编代码，我们能够理解汇编器的优化能力，并分析代码中隐含的低效率。

## 历史观点

Intel 处理器系列简称 x86，每个后继处理器的设计都是后向兼容的 —— 较早版本上编译的代码可以在较新的处理器上运行。

> 摩尔定律 —— 芯片上的晶体每年都会翻一番。（见下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/28.png)

## 程序编码

考虑以下编译过程（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/29.png)

在上图中，gcc （GCC C 编译器）命令调用了一整套的程序，将源代码转为可执行代码。
  - 首先，C 预处理器扩展源代码，插入所有用 #include 命令指定的文件，并扩展所有用 #define 声明指定的宏。
  - 其次，编译器产生两个源文件的汇编代码，名字分别为 p1.s 和 p2.s。
  - 接下来，汇编器会将汇编代码转化为二进制目标代码文件 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
  - 最后，链接器将两个目标代码文件与实现库函数（例如 printf）的代码合并，并产生最终的可执行代码文件 p。（由命令指示符 -o p 指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。

### 机器级代码

计算机系统使用了多种不同形式的抽象，对于机器级编程来说，其中两种抽象尤为重要：

  1. 第一种是由 `指令集体系结构或指令集架构（Instruction Set Architecture, ISA）` 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
  2. 第二种抽象是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

汇编代码非常接近于机器代码。与机器代码的二进制相比，汇编代码的主要特点是它用可读性更好的文本格式表示。

x86-64 的机器代码和原始的 C 代码差别特别大。一些对 C 语言程序员隐藏的处理器状态都是可见的：

  - `程序计数器`（通常称为 “PC”，在 x86-64 中用 `%rip` 来表示）给出将要执行的下一条指令在内存中的地址。
  - `整数寄存器` 文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址（对应 C 语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
  - `条件码寄存器` 保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如用来实现 if 或 while 语句。
  - 一组 `向量寄存器` 可以存放一个或多个整数或浮点数值。

程序内存包含：程序的可执行机器代码、操作系统需要的一些信息、用来管理过程调用和返回的运行时栈、用户分配的内存块（比如用 malloc 库函数分配的）。

### 代码示例

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/53.png)

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/54.png)

机器执行的代码只是一个字节序列，它是对一系列指令的编码，机器对产生这些指令的源代码几乎一无所知。

要查看机器代码文件的内容，有一类称为 `反汇编器（disassembler）` 的程序非常有用，这些程序根据机器代码产生一种类似于汇编代码的格式。（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/55.png)

其中一些关于机器代码和它的反汇编的表示的特性值得注意：

  - x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数减少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需的字节数较多。
  - 设计指令格式的方法是，从某个给定位置开始，可以将字节唯一解码成机器指令。例如，只有指令 pushq %rbx 是以字节值 53 开头的。
  - 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
  - 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的 `q`。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器 call 和 ret 指令添加了 `q` 后缀，同样，省略这些后缀也没有问题。

### 关于格式的注解

所有以 `.` 开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。

在 C 程序中插入汇编代码有两种方法。第一种是，我们可以编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和 C 语言书写的代码结合起来。第二种方法是，我们可以使用 GCC 的内联汇编（inline assembly）特性，用 asm 伪命令可以在 C 程序中包含简短的汇编代码 —— 这种方法的好处是减少了与机器相关的代码量。

## 数据格式

由于是从 16 位体系结构扩展成 32 位，Intel 用术语 `字（word）` 表示 16 位数据类型。下面是 C 语言数据类型在 x86-64 中的大小（见下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/56.png)

大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）、movq（传送四字）。后缀 `l` 用来表示双字，汇编代码也使用后缀 `l` 来表示 4 字节整数和 8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

## 访问信息

一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。它们的名字都以 %r 开头。（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/57.png)

如上图所示，指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16 位操作可以访问最低的两个字节，32 位操作可以访问最低的 4 字节，而 64 位操作可以访问整个寄存器。

### 操作数指示符

大多数指令有一个或多个操作数（operand），指示出执行一个操作中要使用的源数据值，以及放置结果的目的地址。

操作数一般有三种类型：

  1. `立即数（immediate）`：立即数用来表示常数值。（比如 $-577 或 $0x1F）
  2. `寄存器（register）`：它表示某个寄存器中的内容，16 个寄存器的低位 1 字节、2 字节、4 字节或8 字节中的一个作为操作数。
  3. `内存引用`：内存引用会根据计算出来的地址（通常称为有效地址）访问某个内存位置。

内存寻址有多种不同的寻址方式（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/58.png)

### 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。

最简单的数据传送指令是 MOV 类，这些指令把数据从源位置复制到目的位置，不做任何变化（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/59.png)

源操作数指定的值是一个立即数，存储在寄存器或者内存中。目的操作数指定一个位置，要么是一个寄存器要么是一个内存地址。x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令 —— 第一条指令将源值加载到寄存器中，第二条指令将寄存器值写入目的位置。

下面的 MOV 指令示例给出了源和目的类型的五种可能的组合。（第一个是源操作数，第二个是目的操作数）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/60.png)

在将较小的源复制到较大的目的地时使用 MOVZ 和 MOVS 类。MOVZ 类中的指令把目的中剩余的字节填充为 0，而 MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/61.png)

