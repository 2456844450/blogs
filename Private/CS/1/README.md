# 计算机系统漫游

`计算机系统` 是由硬件和系统软件组成的，它们共同工作来运行应用程序。

## 信息就是 位 + 上下文

系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器命令。

> C 编程语言的起源
>
> C 语言与 Unix 操作系统关系密切。C 从一开始就是作为一种用于 Unix 系统的程序语言开发出来的。大部分 Unix 系统内核（操作系统的核心部分），以及所有支撑工具和函数库都是用 C 语言编写的。
>
> C 语言小而简单。
>
> C 语言是为实践目的设计的。

## 程序被其他程序翻译成不同的格式

> 笔记中，以下面这个 `hello` 程序为例

```c
#include <stdio.h>

int main()
{
  printf("hello world\n");
  return 0;
}
```

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/30.png)

为了在系统上运行 xx.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为 `可执行目标程序` 的格式打好包，并以二进制磁盘文件的格式存放起来。目标程序也称为 `可执行目标文件`。

编译过程：

1. 预处理阶段。预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。（如根据 #include 命令读取对应的系统头文件并插入到程序文本中）。
2. 编译阶段。编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。汇编语言是非常有用的，因为它为不同的不同高级语言的不同编译器提供了通用的输出语言。
3. 汇编阶段。接下来，汇编器（as）将 hello.s 翻译成机器语言指令，将这些指令打包成一种叫做 `可重定向定位目标程序` 的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。
4. 链接阶段。链接器（ld）负责处理与系统预编译文件（如 printf.o）的合并，最后得到 hello 文件，它是一个 `可执行目标文件（或者简称为可执行文件）`，可以被加载到内存中，由系统执行。

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/31.png)

了解编译系统如何工作是大有益处的：

- 优化程序性能。
- 理解链接时出现的错误。
- 避免安全漏洞。

## 处理器读并解释储存在内存中的命令

shell 是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的命令，它将加载并运行这个文件。

### 系统的硬件组成

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/32.png)

#### 总线

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64 位）。

#### I/O 设备

I/O（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个 I/O 设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。

每一个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连。控制器与适配器之间的区别主要在于它们的封装方式。控制器是 I/O 设备本身或者系统的主印制电板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

#### 主存

主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。

#### 处理器

中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，并更新程序计数器，使其指向下一条指令。

CPU 在指令的要求下可能会执行这些操作：

  - 加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容。
  - 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
  - 操作：把两个寄存器的内容复制到 ALU（算术/逻辑单元），ALU 对这两个字做算术运算，并将结果放到一个寄存器中，以覆盖该寄存器中原来的内容。
  - 跳转：从指令本身中抽取一个字，并将这个字复制程序计数器（PC）中，以覆盖 PC 中原来的值。

处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。

### 运行 hello 程序

初始时，shell 程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串 “./hello” 后，shell 程序将字符逐一读入寄存器，再把它存放到内存中（如下图）

当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的键入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会输出的字符串 “hello world\n”。

利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。

一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将 “hello world\n” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。

## 高速缓存至关重要

示例揭示了一个问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。

根据机械原理，较大的存储设备要比较小的存储设备运行地慢，而快速设备的造价远高于同类的低速设备。

从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大 1000 万倍，处理器从寄存器文件中读数据比主存中读取几乎要快 100 倍。

针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器（简称 cache 或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。高速缓存存储量大，读取速度与寄存器相近。

## 存储设备形成层次结构

在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为了一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/33.png)

## 操作系统管理硬件

所有应用程序对硬件的操作尝试都必须通过操作系统。

操作系统有两个基本功能：

  - 防止硬件被失控的应用程序滥用。
  - 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 的抽象表示，进程则是对处理器、主存和 I/O 设备的抽象表示。（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/34.png)

### 进程

进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如 PC 和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行 `上下文切换`，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权转移到新进程。新进程就会从它上次停止的地方开始（如下图）。

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/35.png)

示例场景中有两个并发的进程：shell 进程和 hello 进程。最开始，只有 shell 进程在运行，即等待命令行上的输入。当我们让它运行 hello 程序时，shell 通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存 shell 的上下文，创建一个新的 hello 进程及其上下文，然后将控制权传给新的 hello 进程。hello 进程终止后，操作系统恢复 shell 进程的上下文，并将控制权传回给它，shell 进程会继续等待下一个命令行的输入。

从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回给应用程序。

> 内核并不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合。

### 线程

在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可用运行得更快的方法。

### 虚拟内存

`虚拟内存` 是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。（如下图）

  - 程序代码和数据。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。
  - 堆。代码和数据区后紧随着的是运行时堆。堆可以在运行时动态地扩展和收缩。
  - 共享库。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。
  - 栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。
  - 内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们应该调用内核来执行这些操作。

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/36.png)

虚拟内存的基本思想就是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。

### 文件

文件就是字节序列。每个 I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数用读写文件来实现的。

## 系统之间利用网络通信

现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个 I/O 设备。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。（见下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/37.png)

下图是 telnet 应用的一个示例（见下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/38.png)

## 重要主题

### Amdahl 定律

Amdahl 定律：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

### 并发与并行

`并发（concurrency）` 是一个通用的概念，指一个同时具有多个活动的系统；而 `并行（parallelism）` 指的是用并发来使一个系统运行的更快。

#### 线程级并发

计算机很早之前就有了并发执行的支持，但是这种并发支持只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。处理器需要在多个任务间切换，这种配置称为单处理器系统。

使用线程，我们可以在一个进程中执行多个控制流。`多核处理器` 和 `超线程` 带来了多处理器系统。

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/41.png)

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/cs/42.png)

### 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。例如，为一组函数规定一个简单的应用程序接口（API）就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。

文件是 I/O 设备的抽象，虚拟内存是对存储器的抽象，进程是对正在运行的程序的抽象，虚拟机是对整个计算机的抽象，包括操作系统、处理器和程序。

## 小结

计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们根据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。

处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构 —— CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次的存储设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化 C 程序的性能。

操作系统内核是应用程序与硬件之间的媒介。它提供三个基本的抽象：文件是对 I/O 设备的抽象、虚拟内存是对主存和磁盘的抽象、进程是对主存、处理器和 I/O 设备的抽象。

最后，网络提供了计算机系统之间通信的手段，从特殊系统的角度来看，网络就是一种 I/O 设备。
