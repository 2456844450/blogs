# 计算机系统漫游

`计算机系统` 是由硬件和系统软件组成的，它们共同工作来运行应用程序。

## 信息就是 位 + 上下文

系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器命令。

> C 编程语言的起源
>
> C 语言与 Unix 操作系统关系密切。C 从一开始就是作为一种用于 Unix 系统的程序语言开发出来的。大部分 Unix 系统内核（操作系统的核心部分），以及所有支撑工具和函数库都是用 C 语言编写的。
>
> C 语言小而简单。
>
> C 语言是为实践目的设计的。

## 程序被其他程序翻译成不同的格式

> 笔记中，以下面这个 `hello` 程序为例

```c
#include <stdio.h>

int main()
{
  printf("hello world\n");
  return 0;
}
```

为了在系统上运行 xx.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为 `可执行目标程序` 的格式打好包，并以二进制磁盘文件的格式存放起来。目标程序也称为 `可执行目标文件`。

编译过程：

1. 预处理阶段。预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。（如根据 #include 命令读取对应的系统头文件并插入到程序文本中）。
2. 编译阶段。编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。汇编语言是非常有用的，因为它为不同的不同高级语言的不同编译器提供了通用的输出语言。
3. 汇编阶段。接下来，汇编器（as）将 hello.s 翻译成机器语言指令，将这些指令打包成一种叫做 `可重定向定位目标程序` 的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。
4. 链接阶段。链接器（ld）负责处理与系统预编译文件（如 printf.o）的合并，最后得到 hello 文件，它是一个 `可执行目标文件（或者简称为可执行文件）`，可以被加载到内存中，由系统执行。

了解编译系统如何工作是大有益处的：

- 优化程序性能。
- 理解链接时出现的错误。
- 避免安全漏洞。

## 处理器读并解释储存在内存中的命令

shell 是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的命令，它将加载并运行这个文件。

### 系统的硬件组成

#### 总线

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64 位）。

#### I/O 设备

I/O（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个 I/O 设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。

每一个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连。控制器与适配器之间的区别主要在于它们的封装方式。控制器是 I/O 设备本身或者系统的主印制电板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

#### 主存

主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。

#### 处理器

中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，并更新程序计数器，使其指向下一条指令。

CPU 在指令的要求下可能会执行这些操作：

  - 加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容。
  - 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
  - 操作：把两个寄存器的内容复制到 ALU（算术/逻辑单元），ALU 对这两个字做算术运算，并将结果放到一个寄存器中，以覆盖该寄存器中原来的内容。
  - 跳转：从指令本身中抽取一个字，并将这个字复制程序计数器（PC）中，以覆盖 PC 中原来的值。

处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。

### 运行 hello 程序

初始时，shell 程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串 “./hello” 后，shell 程序将字符逐一读入寄存器，再把它存放到内存中（如下图）

当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的键入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会输出的字符串 “hello world\n”。

利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。

一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将 “hello world\n” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。

## 高速缓存至关重要

示例揭示了一个问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。

根据机械原理，较大的存储设备要比较小的存储设备运行地慢，而快速设备的造价远高于同类的低速设备。

从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大 1000 万倍，处理器从寄存器文件中读数据比主存中读取几乎要快 100 倍。

针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器（简称 cache 或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。高速缓存存储量大，读取速度与寄存器相近。

## 存储设备形成层次结构

在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为了一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。（如下图）

## 操作系统管理硬件

所有应用程序对硬件的操作尝试都必须通过操作系统。

操作系统有两个基本功能：

  - 防止硬件被失控的应用程序滥用。
  - 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 的抽象表示，进程则是对处理器、主存和 I/O 设备的抽象表示。

## 进程

进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如 PC 和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行 `上下文切换`，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权转移到新进程。新进程就会从它上次停止的地方开始（如下图）。

示例场景中有两个并发的进程：shell 进程和 hello 进程。最开始，只有 shell 进程在运行，即等待命令行上的输入。当我们让它运行 hello 程序时，shell 通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存 shell 的上下文，创建一个新的 hello 进程及其上下文，然后将控制权传给新的 hello 进程。hello 进程终止后，操作系统恢复 shell 进程的上下文，并将控制权传回给它，shell 进程会继续等待下一个命令行的输入。